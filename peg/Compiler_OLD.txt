Start
    = a:( Token / Text )+ { return a }
    / '' { return [] }

Text
    = a:_Symbol { return new TextCompilerToken( text(), location().start.line, location().start.column ) }

Token
    = '{{' _ a:( Expression / Literal ) _ '}}' { return a }

Expression
    = a:Identifier b:( ObjectAccess / ArrayAccess / Invocation )* { return new ExpressionCompilerToken( a, b, text(), location().start.line, location().start.column ) }

Identifier
    = b:'@'? a:_Identifier { return new IdentifierCompilerToken( a, '@' === b, text(), location().start.line, location().start.column ) }

ObjectAccess
    = _ '.' _ a:_Identifier { return new ObjectAccessCompilerToken( a, text(), location().start.line, location().start.column ) }

ArrayAccess
    = _ '[' _ a:( Expression / Literal ) _ ']' { return new ArrayAccessCompilerToken( a, text(), location().start.line, location().start.column ) }

Invocation
    = _ '(' _ a:_ArgumentList? _ ')' { return new InvocationCompilerToken( a ?? [], text(), location().start.line, location().start.column ) }

Literal
    = a:( _Null / _Boolean / _String / _Float / _Integer ) { return new LiteralCompilerToken( a, text(), location().start.line, location().start.column ) }

_
    = [ \t\r\n]*

_Symbol
    = a:. { return a }

_Null
    = 'null' { return null }
    / 'NULL' { return null }

_Boolean
    = 'true' { return true }
    / 'TRUE' { return true }
    / 'false' { return false }
    / 'FALSE' { return false }

_Integer
    = '0' { return 0 }
    / a:( '-'? [1-9] [0-9]* ) { return parseInt( [ a[0], a[1], ... a[2] ].join( '' ), 10 ) }

_Float
    = a:( '-'? [1-9] [0-9]* '.' [0-9]+ ) { return parseFloat( [ a[0], a[1], a[2].join( '' ), '.', a[4].join( '' ) ].join( '' ) ) }
    / a:( '-'? ( '0' / '' ) '.' [0-9]+ ) { return parseFloat( [ ... a.slice( 0, 3 ), ... a[3] ].join( '' ) ) }

_String
    = "'" a:( "\\'" / "\\\\" / [^'] )* "'" { return a.map( ( v: any ) => -1 < [ "\\'", "\\\\" ].indexOf( v ) ? v[1] : v ).join( '' ) }
    / '"' a:( '\\"' / "\\\\" / [^"] )* '"' { return a.map( ( v: any ) => -1 < [ '\\"', "\\\\" ].indexOf( v ) ? v[1] : v ).join( '' ) }
    / "`" a:( ! "${" ( "\\`" / "\\\\" / [^`] ) )* "`" { return a.map( ( [ , v ]: any ) => -1 < [ "\\`", "\\\\" ].indexOf( v ) ? v[1] : v ).join( '' ) }

_Identifier
    = !( _Null / _Boolean ) a:( [a-zA-Z_$] [a-zA-Z0-9_$]* ) { return [ a[0], ... a[1] ].join( '' ) }

_ArgumentList
    = a:_Argument b:( _ ',' _ _Argument )* { return [ a, ...b.map( ( [ ,,, v ]: any ) => v ) ] }

_Argument
    = a:( Expression / Literal ) { return a }
