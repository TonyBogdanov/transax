import { Logger, Options as LoggerOptions } from './Logger';

/* peg:start */
// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs

interface FilePosition {
    offset: number;
    line: number;
    column: number;
}

interface FileRange {
    start: FilePosition;
    end: FilePosition;
    source: string;
}

interface LiteralExpectation {
    type: "literal";
    text: string;
    ignoreCase: boolean;
}

interface ClassParts extends Array<string | ClassParts> {
}

interface ClassExpectation {
    type: "class";
    parts: ClassParts;
    inverted: boolean;
    ignoreCase: boolean;
}

interface AnyExpectation {
    type: "any";
}

interface EndExpectation {
    type: "end";
}

interface OtherExpectation {
    type: "other";
    description: string;
}

type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;

function peg$padEnd( str: string, targetLength: number, padString: string ) {
    padString = padString || ' ';
    if ( str.length > targetLength ) {
        return str;
    }
    targetLength -= str.length;
    padString += padString.repeat( targetLength );
    return str + padString.slice( 0, targetLength );
}

class PeggySyntaxError extends Error {
    public static buildMessage( expected: Expectation[], found: string | null ) {
        function hex( ch: string ): string {
            return ch.charCodeAt( 0 ).toString( 16 ).toUpperCase();
        }

        function literalEscape( s: string ): string {
            return s
                .replace( /\\/g, "\\\\" )
                .replace( /"/g, "\\\"" )
                .replace( /\0/g, "\\0" )
                .replace( /\t/g, "\\t" )
                .replace( /\n/g, "\\n" )
                .replace( /\r/g, "\\r" )
                .replace( /[\x00-\x0F]/g, ( ch ) => "\\x0" + hex( ch ) )
                .replace( /[\x10-\x1F\x7F-\x9F]/g, ( ch ) => "\\x" + hex( ch ) );
        }

        function classEscape( s: string ): string {
            return s
                .replace( /\\/g, "\\\\" )
                .replace( /\]/g, "\\]" )
                .replace( /\^/g, "\\^" )
                .replace( /-/g, "\\-" )
                .replace( /\0/g, "\\0" )
                .replace( /\t/g, "\\t" )
                .replace( /\n/g, "\\n" )
                .replace( /\r/g, "\\r" )
                .replace( /[\x00-\x0F]/g, ( ch ) => "\\x0" + hex( ch ) )
                .replace( /[\x10-\x1F\x7F-\x9F]/g, ( ch ) => "\\x" + hex( ch ) );
        }

        function describeExpectation( expectation: Expectation ) {
            switch ( expectation.type ) {
                case "literal":
                    return "\"" + literalEscape( expectation.text ) + "\"";
                case "class":
                    const escapedParts = expectation.parts.map( ( part ) => {
                        return Array.isArray( part )
                            ? classEscape( part[ 0 ] as string ) + "-" + classEscape( part[ 1 ] as string )
                            : classEscape( part );
                    } );

                    return "[" + ( expectation.inverted ? "^" : "" ) + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }

        function describeExpected( expected1: Expectation[] ) {
            const descriptions = expected1.map( describeExpectation );
            let i: number;
            let j: number;

            descriptions.sort();

            if ( descriptions.length > 0 ) {
                for ( i = 1, j = 1; i < descriptions.length; i++ ) {
                    if ( descriptions[ i - 1 ] !== descriptions[ i ] ) {
                        descriptions[ j ] = descriptions[ i ];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch ( descriptions.length ) {
                case 1:
                    return descriptions[ 0 ];

                case 2:
                    return descriptions[ 0 ] + " or " + descriptions[ 1 ];

                default:
                    return descriptions.slice( 0, -1 ).join( ", " )
                        + ", or "
                        + descriptions[ descriptions.length - 1 ];
            }
        }

        function describeFound( found1: string | null ) {
            return found1 ? "\"" + literalEscape( found1 ) + "\"" : "end of input";
        }

        return "Expected " + describeExpected( expected ) + " but " + describeFound( found ) + " found.";
    }

    public message: string;
    public expected: Expectation[];
    public found: string | null;
    public location: FileRange;
    public name: string;

    constructor( message: string, expected: Expectation[], found: string | null, location: FileRange ) {
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "PeggySyntaxError";

        if ( typeof ( Object as any ).setPrototypeOf === "function" ) {
            ( Object as any ).setPrototypeOf( this, PeggySyntaxError.prototype );
        } else {
            ( this as any ).__proto__ = PeggySyntaxError.prototype;
        }
        if ( typeof ( Error as any ).captureStackTrace === "function" ) {
            ( Error as any ).captureStackTrace( this, PeggySyntaxError );
        }
    }

    format( sources: { grammarSource?: string; text: string }[] ): string {
        let str = 'Error: ' + this.message;
        if ( this.location ) {
            let src: string[] | null = null;
            let k;
            for ( k = 0; k < sources.length; k++ ) {
                if ( sources[ k ].grammarSource === this.location.source ) {
                    src = sources[ k ].text.split( /\r\n|\n|\r/g );
                    break;
                }
            }
            let s = this.location.start;
            let loc = this.location.source + ':' + s.line + ':' + s.column;
            if ( src ) {
                let e = this.location.end;
                let filler = peg$padEnd( '', s.line.toString().length, ' ' );
                let line = src[ s.line - 1 ];
                let last = s.line === e.line ? e.column : line.length + 1;
                str += '\n --> ' + loc + '\n' + filler + ' |\n' + s.line + ' | ' + line + '\n' + filler + ' | ' +
                    peg$padEnd( '', s.column - 1, ' ' ) +
                    peg$padEnd( '', last - s.column, '^' );
            } else {
                str += '\n at ' + loc;
            }
        }
        return str;
    }
}

function peg$parse( input: string, options?: ParseOptions ) {
    options = options !== undefined ? options : {};

    const peg$FAILED: Readonly<any> = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions: { [ id: string ]: any } = { Start: peg$parseStart };
    let peg$startRuleFunction: () => any = peg$parseStart;

    const peg$c0 = function ( a: any ): any {
        return a.flat().filter( ( v: any ) => v instanceof Token )
    };
    const peg$c1 = "(";
    const peg$c2 = peg$literalExpectation( "(", false );
    const peg$c3 = /^[,)]/;
    const peg$c4 = peg$classExpectation( [ ",", ")" ], false, false );
    const peg$c5 = function ( a: any, b: any ): any {
        return new Token( a, b, text(), location().start.line, location().start.column )
    };
    const peg$c6 = /^[ \t\r\n]/;
    const peg$c7 = peg$classExpectation( [ " ", "\t", "\r", "\n" ], false, false );
    const peg$c8 = /^[^a-zA-Z_$]/;
    const peg$c9 = peg$classExpectation( [ [ "a", "z" ], [ "A", "Z" ], "_", "$" ], true, false );
    const peg$c10 = peg$anyExpectation();
    const peg$c11 = /^[a-zA-Z_$]/;
    const peg$c12 = peg$classExpectation( [ [ "a", "z" ], [ "A", "Z" ], "_", "$" ], false, false );
    const peg$c13 = /^[a-zA-Z_$0-9]/;
    const peg$c14 = peg$classExpectation( [ [ "a", "z" ], [ "A", "Z" ], "_", "$", [ "0", "9" ] ], false, false );
    const peg$c15 = function (): any {
        return text()
    };
    const peg$c16 = "'";
    const peg$c17 = peg$literalExpectation( "'", false );
    const peg$c18 = "\\'";
    const peg$c19 = peg$literalExpectation( "\\'", false );
    const peg$c20 = /^[^']/;
    const peg$c21 = peg$classExpectation( [ "'" ], true, false );
    const peg$c22 = function ( a: any ): any {
        return a.map( ( v: any ) => "\\'" === v ? v[ 1 ] : v ).join( '' )
    };
    const peg$c23 = "\"";
    const peg$c24 = peg$literalExpectation( "\"", false );
    const peg$c25 = "\\\"";
    const peg$c26 = peg$literalExpectation( "\\\"", false );
    const peg$c27 = /^[^"]/;
    const peg$c28 = peg$classExpectation( [ "\"" ], true, false );
    const peg$c29 = function ( a: any ): any {
        return a.map( ( v: any ) => '\\"' === v ? v[ 1 ] : v ).join( '' )
    };
    const peg$c30 = "`";
    const peg$c31 = peg$literalExpectation( "`", false );
    const peg$c32 = "${";
    const peg$c33 = peg$literalExpectation( "${", false );
    const peg$c34 = "\\`";
    const peg$c35 = peg$literalExpectation( "\\`", false );
    const peg$c36 = /^[^`]/;
    const peg$c37 = peg$classExpectation( [ "`" ], true, false );
    const peg$c38 = function ( a: any ): any {
        return a.map( ( [ , v ]: any ) => "\\`" === v ? v[ 1 ] : v ).join( '' )
    };

    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [ { line: 1, column: 1 } ];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected: Expectation[] = [];
    let peg$silentFails = 0;

    let peg$result;

    if ( options.startRule !== undefined ) {
        if ( !( options.startRule in peg$startRuleFunctions ) ) {
            throw new Error( "Can't start parsing from rule \"" + options.startRule + "\"." );
        }

        peg$startRuleFunction = peg$startRuleFunctions[ options.startRule ];
    }

    function text(): string {
        return input.substring( peg$savedPos, peg$currPos );
    }

    function location(): FileRange {
        return peg$computeLocation( peg$savedPos, peg$currPos );
    }

    function expected( description: string, location1?: FileRange ) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation( peg$savedPos, peg$currPos );

        throw peg$buildStructuredError(
            [ peg$otherExpectation( description ) ],
            input.substring( peg$savedPos, peg$currPos ),
            location1
        );
    }

    function error( message: string, location1?: FileRange ) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation( peg$savedPos, peg$currPos );

        throw peg$buildSimpleError( message, location1 );
    }

    function peg$literalExpectation( text1: string, ignoreCase: boolean ): LiteralExpectation {
        return { type: "literal", text: text1, ignoreCase: ignoreCase };
    }

    function peg$classExpectation( parts: ClassParts, inverted: boolean, ignoreCase: boolean ): ClassExpectation {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation(): AnyExpectation {
        return { type: "any" };
    }

    function peg$endExpectation(): EndExpectation {
        return { type: "end" };
    }

    function peg$otherExpectation( description: string ): OtherExpectation {
        return { type: "other", description: description };
    }

    function peg$computePosDetails( pos: number ) {
        let details = peg$posDetailsCache[ pos ];
        let p;

        if ( details ) {
            return details;
        } else {
            p = pos - 1;
            while ( !peg$posDetailsCache[ p ] ) {
                p--;
            }

            details = peg$posDetailsCache[ p ];
            details = {
                line: details.line,
                column: details.column
            };

            while ( p < pos ) {
                if ( input.charCodeAt( p ) === 10 ) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[ pos ] = details;

            return details;
        }
    }

    function peg$computeLocation( startPos: number, endPos: number ): FileRange {
        const startPosDetails = peg$computePosDetails( startPos );
        const endPosDetails = peg$computePosDetails( endPos );

        return {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }

    function peg$fail( expected1: Expectation ) {
        if ( peg$currPos < peg$maxFailPos ) {
            return;
        }

        if ( peg$currPos > peg$maxFailPos ) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push( expected1 );
    }

    function peg$buildSimpleError( message: string, location1: FileRange ) {
        return new PeggySyntaxError( message, [], "", location1 );
    }

    function peg$buildStructuredError( expected1: Expectation[], found: string | null, location1: FileRange ) {
        return new PeggySyntaxError(
            PeggySyntaxError.buildMessage( expected1, found ),
            expected1,
            found,
            location1
        );
    }

    function peg$parseStart(): any {
        let s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parse_Prefix();
        if ( s3 as any === peg$FAILED ) {
            s3 = null;
        }
        if ( s3 as any !== peg$FAILED ) {
            s4 = peg$parseToken();
            if ( s4 as any !== peg$FAILED ) {
                s3 = [ s3, s4 ];
                s2 = s3;
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if ( s2 as any === peg$FAILED ) {
            s2 = peg$parse_Symbol();
        }
        while ( s2 as any !== peg$FAILED ) {
            s1.push( s2 );
            s2 = peg$currPos;
            s3 = peg$parse_Prefix();
            if ( s3 as any === peg$FAILED ) {
                s3 = null;
            }
            if ( s3 as any !== peg$FAILED ) {
                s4 = peg$parseToken();
                if ( s4 as any !== peg$FAILED ) {
                    s3 = [ s3, s4 ];
                    s2 = s3;
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if ( s2 as any === peg$FAILED ) {
                s2 = peg$parse_Symbol();
            }
        }
        if ( s1 as any !== peg$FAILED ) {
            peg$savedPos = s0;
            s1 = peg$c0( s1 );
        }
        s0 = s1;

        return s0;
    }

    function peg$parseToken(): any {
        let s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        s1 = peg$parse_Name();
        if ( s1 as any !== peg$FAILED ) {
            s2 = peg$parse_();
            if ( s2 as any !== peg$FAILED ) {
                if ( input.charCodeAt( peg$currPos ) === 40 ) {
                    s3 = peg$c1;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c2 );
                    }
                }
                if ( s3 as any !== peg$FAILED ) {
                    s4 = peg$parse_();
                    if ( s4 as any !== peg$FAILED ) {
                        s5 = peg$parse_String();
                        if ( s5 as any !== peg$FAILED ) {
                            s6 = peg$parse_();
                            if ( s6 as any !== peg$FAILED ) {
                                if ( peg$c3.test( input.charAt( peg$currPos ) ) ) {
                                    s7 = input.charAt( peg$currPos );
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if ( peg$silentFails === 0 ) {
                                        peg$fail( peg$c4 );
                                    }
                                }
                                if ( s7 as any !== peg$FAILED ) {
                                    peg$savedPos = s0;
                                    s1 = peg$c5( s1, s5 );
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parse_(): any {
        let s0, s1;

        s0 = [];
        if ( peg$c6.test( input.charAt( peg$currPos ) ) ) {
            s1 = input.charAt( peg$currPos );
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if ( peg$silentFails === 0 ) {
                peg$fail( peg$c7 );
            }
        }
        while ( s1 as any !== peg$FAILED ) {
            s0.push( s1 );
            if ( peg$c6.test( input.charAt( peg$currPos ) ) ) {
                s1 = input.charAt( peg$currPos );
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if ( peg$silentFails === 0 ) {
                    peg$fail( peg$c7 );
                }
            }
        }

        return s0;
    }

    function peg$parse_Prefix(): any {
        let s0;

        if ( peg$c8.test( input.charAt( peg$currPos ) ) ) {
            s0 = input.charAt( peg$currPos );
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if ( peg$silentFails === 0 ) {
                peg$fail( peg$c9 );
            }
        }

        return s0;
    }

    function peg$parse_Symbol(): any {
        let s0;

        if ( input.length > peg$currPos ) {
            s0 = input.charAt( peg$currPos );
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if ( peg$silentFails === 0 ) {
                peg$fail( peg$c10 );
            }
        }

        return s0;
    }

    function peg$parse_Name(): any {
        let s0, s1, s2, s3;

        s0 = peg$currPos;
        if ( peg$c11.test( input.charAt( peg$currPos ) ) ) {
            s1 = input.charAt( peg$currPos );
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if ( peg$silentFails === 0 ) {
                peg$fail( peg$c12 );
            }
        }
        if ( s1 as any !== peg$FAILED ) {
            s2 = [];
            if ( peg$c13.test( input.charAt( peg$currPos ) ) ) {
                s3 = input.charAt( peg$currPos );
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if ( peg$silentFails === 0 ) {
                    peg$fail( peg$c14 );
                }
            }
            while ( s3 as any !== peg$FAILED ) {
                s2.push( s3 );
                if ( peg$c13.test( input.charAt( peg$currPos ) ) ) {
                    s3 = input.charAt( peg$currPos );
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c14 );
                    }
                }
            }
            if ( s2 as any !== peg$FAILED ) {
                peg$savedPos = s0;
                s1 = peg$c15();
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    function peg$parse_String(): any {
        let s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        if ( input.charCodeAt( peg$currPos ) === 39 ) {
            s1 = peg$c16;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if ( peg$silentFails === 0 ) {
                peg$fail( peg$c17 );
            }
        }
        if ( s1 as any !== peg$FAILED ) {
            s2 = [];
            if ( input.substr( peg$currPos, 2 ) === peg$c18 ) {
                s3 = peg$c18;
                peg$currPos += 2;
            } else {
                s3 = peg$FAILED;
                if ( peg$silentFails === 0 ) {
                    peg$fail( peg$c19 );
                }
            }
            if ( s3 as any === peg$FAILED ) {
                if ( peg$c20.test( input.charAt( peg$currPos ) ) ) {
                    s3 = input.charAt( peg$currPos );
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c21 );
                    }
                }
            }
            while ( s3 as any !== peg$FAILED ) {
                s2.push( s3 );
                if ( input.substr( peg$currPos, 2 ) === peg$c18 ) {
                    s3 = peg$c18;
                    peg$currPos += 2;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c19 );
                    }
                }
                if ( s3 as any === peg$FAILED ) {
                    if ( peg$c20.test( input.charAt( peg$currPos ) ) ) {
                        s3 = input.charAt( peg$currPos );
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if ( peg$silentFails === 0 ) {
                            peg$fail( peg$c21 );
                        }
                    }
                }
            }
            if ( s2 as any !== peg$FAILED ) {
                if ( input.charCodeAt( peg$currPos ) === 39 ) {
                    s3 = peg$c16;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c17 );
                    }
                }
                if ( s3 as any !== peg$FAILED ) {
                    peg$savedPos = s0;
                    s1 = peg$c22( s2 );
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if ( s0 as any === peg$FAILED ) {
            s0 = peg$currPos;
            if ( input.charCodeAt( peg$currPos ) === 34 ) {
                s1 = peg$c23;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if ( peg$silentFails === 0 ) {
                    peg$fail( peg$c24 );
                }
            }
            if ( s1 as any !== peg$FAILED ) {
                s2 = [];
                if ( input.substr( peg$currPos, 2 ) === peg$c25 ) {
                    s3 = peg$c25;
                    peg$currPos += 2;
                } else {
                    s3 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c26 );
                    }
                }
                if ( s3 as any === peg$FAILED ) {
                    if ( peg$c27.test( input.charAt( peg$currPos ) ) ) {
                        s3 = input.charAt( peg$currPos );
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if ( peg$silentFails === 0 ) {
                            peg$fail( peg$c28 );
                        }
                    }
                }
                while ( s3 as any !== peg$FAILED ) {
                    s2.push( s3 );
                    if ( input.substr( peg$currPos, 2 ) === peg$c25 ) {
                        s3 = peg$c25;
                        peg$currPos += 2;
                    } else {
                        s3 = peg$FAILED;
                        if ( peg$silentFails === 0 ) {
                            peg$fail( peg$c26 );
                        }
                    }
                    if ( s3 as any === peg$FAILED ) {
                        if ( peg$c27.test( input.charAt( peg$currPos ) ) ) {
                            s3 = input.charAt( peg$currPos );
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if ( peg$silentFails === 0 ) {
                                peg$fail( peg$c28 );
                            }
                        }
                    }
                }
                if ( s2 as any !== peg$FAILED ) {
                    if ( input.charCodeAt( peg$currPos ) === 34 ) {
                        s3 = peg$c23;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if ( peg$silentFails === 0 ) {
                            peg$fail( peg$c24 );
                        }
                    }
                    if ( s3 as any !== peg$FAILED ) {
                        peg$savedPos = s0;
                        s1 = peg$c29( s2 );
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if ( s0 as any === peg$FAILED ) {
                s0 = peg$currPos;
                if ( input.charCodeAt( peg$currPos ) === 96 ) {
                    s1 = peg$c30;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if ( peg$silentFails === 0 ) {
                        peg$fail( peg$c31 );
                    }
                }
                if ( s1 as any !== peg$FAILED ) {
                    s2 = [];
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    peg$silentFails++;
                    if ( input.substr( peg$currPos, 2 ) === peg$c32 ) {
                        s5 = peg$c32;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if ( peg$silentFails === 0 ) {
                            peg$fail( peg$c33 );
                        }
                    }
                    peg$silentFails--;
                    if ( s5 as any === peg$FAILED ) {
                        s4 = undefined;
                    } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                    if ( s4 as any !== peg$FAILED ) {
                        if ( input.substr( peg$currPos, 2 ) === peg$c34 ) {
                            s5 = peg$c34;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if ( peg$silentFails === 0 ) {
                                peg$fail( peg$c35 );
                            }
                        }
                        if ( s5 as any === peg$FAILED ) {
                            if ( peg$c36.test( input.charAt( peg$currPos ) ) ) {
                                s5 = input.charAt( peg$currPos );
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if ( peg$silentFails === 0 ) {
                                    peg$fail( peg$c37 );
                                }
                            }
                        }
                        if ( s5 as any !== peg$FAILED ) {
                            s4 = [ s4, s5 ];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    while ( s3 as any !== peg$FAILED ) {
                        s2.push( s3 );
                        s3 = peg$currPos;
                        s4 = peg$currPos;
                        peg$silentFails++;
                        if ( input.substr( peg$currPos, 2 ) === peg$c32 ) {
                            s5 = peg$c32;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if ( peg$silentFails === 0 ) {
                                peg$fail( peg$c33 );
                            }
                        }
                        peg$silentFails--;
                        if ( s5 as any === peg$FAILED ) {
                            s4 = undefined;
                        } else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                        if ( s4 as any !== peg$FAILED ) {
                            if ( input.substr( peg$currPos, 2 ) === peg$c34 ) {
                                s5 = peg$c34;
                                peg$currPos += 2;
                            } else {
                                s5 = peg$FAILED;
                                if ( peg$silentFails === 0 ) {
                                    peg$fail( peg$c35 );
                                }
                            }
                            if ( s5 as any === peg$FAILED ) {
                                if ( peg$c36.test( input.charAt( peg$currPos ) ) ) {
                                    s5 = input.charAt( peg$currPos );
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if ( peg$silentFails === 0 ) {
                                        peg$fail( peg$c37 );
                                    }
                                }
                            }
                            if ( s5 as any !== peg$FAILED ) {
                                s4 = [ s4, s5 ];
                                s3 = s4;
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    }
                    if ( s2 as any !== peg$FAILED ) {
                        if ( input.charCodeAt( peg$currPos ) === 96 ) {
                            s3 = peg$c30;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if ( peg$silentFails === 0 ) {
                                peg$fail( peg$c31 );
                            }
                        }
                        if ( s3 as any !== peg$FAILED ) {
                            peg$savedPos = s0;
                            s1 = peg$c38( s2 );
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }

        return s0;
    }

    peg$result = peg$startRuleFunction();

    if ( peg$result !== peg$FAILED && peg$currPos === input.length ) {
        return peg$result;
    } else {
        if ( peg$result !== peg$FAILED && peg$currPos < input.length ) {
            peg$fail( peg$endExpectation() );
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? input.charAt( peg$maxFailPos ) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation( peg$maxFailPos, peg$maxFailPos + 1 )
                : peg$computeLocation( peg$maxFailPos, peg$maxFailPos )
        );
    }
}

interface ParseOptions {
    filename?: string;
    startRule?: string;
    tracer?: any;

    [ key: string ]: any;
}

type ParseFunction = ( input: string, options?: ParseOptions ) => any;
const parse: ParseFunction = peg$parse;

/* peg:stop */

export class Token {
    name: string;
    key: string;
    text: string;
    line: number;
    column: number;
    source?: string;

    constructor( name: string, key: string, text: string, line: number, column: number, source?: string ) {
        this.name = name;
        this.key = key;
        this.text = text;
        this.line = line;
        this.column = column;
        this.source = source;
    }
}

export class Options {
    names: string[] = [ '$t' ];
    loggerOptions: LoggerOptions | Object = {};

    constructor( values: Object = {} ) {
        if ( 'names' in values ) {
            // TODO validation
            this.names = <string[]> values.names;
        }

        if ( 'loggerOptions' in values ) {
            // TODO validation
            this.loggerOptions = <LoggerOptions | Object> values.loggerOptions;
        }
    }
}

export class Analyzer {
    options: Options;
    logger: Logger;

    constructor( options: Options | Object = {} ) {
        this.options = options instanceof Options ? options : new Options( options );
        this.logger = new Logger( 'Analyzer', this.options.loggerOptions );
    }

    skip( token: Token, source?: string ): void {
        this.logger.verbose( `Skipping ${ token.text } because: "${ token.name }" isn't in the list of allowed names ${
            source ? `in: ${ source }::${ token.line }:${ token.column }.` :
                `at: ${ token.line }:${ token.column }.` }`,
        );
    }

    analyze( code: string, source?: string ): Token[] {
        this.logger.log( `Analyzing: ${ source || '[inline code]' }.` );
        const result: Token[] = [];

        for ( const token of parse( code ) ) {
            if ( -1 === this.options.names.indexOf( token.name ) ) {
                this.skip( token, source );
                continue;
            }

            token.source = source;
            result.push( token );
        }

        return result;
    }
}
