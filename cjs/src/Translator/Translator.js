"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const Logger_1=require("../Logger/Logger");class Options{constructor(o={}){var l;this.translations=null!=(l=o.translations)?l:{},this.fallbackLocale=null!=(l=o.fallbackLocale)?l:void 0,this.logger=null!=(l=o.logger)?l:new Logger_1.default({namespace:"Translator"})}}class Translator{constructor(o={}){this.options=new Options(o)}translate(o,l={}){var s;if(l.locale)if(l.locale in this.options.translations){if(o in this.options.translations[l.locale])return this.options.translations[l.locale][o](null!=(s=l.params)?s:{},null!=(s=l.globals)?s:{});this.options.logger.verbose(`Key "${o}" does not exist in dictionary for locale: "${l.locale}", resorting to fallback locale.`)}else this.options.logger.verbose(`Locale: "${l.locale}" does not exist in dictionary, resorting to fallback locale.`);else this.options.logger.verbose("Locale is not specified, resorting to fallback locale.");if(this.options.fallbackLocale)if(this.options.fallbackLocale in this.options.translations){if(o in this.options.translations[this.options.fallbackLocale])return this.options.translations[this.options.fallbackLocale][o](null!=(s=l.params)?s:{},null!=(s=l.globals)?s:{});this.options.logger.log(`Key: "${o}" does not exist in dictionary for fallback locale: "${this.options.fallbackLocale}".`)}else this.options.logger.log(`Fallback locale: "${this.options.fallbackLocale}" does not exist in dictionary.`);else this.options.logger.log("Fallback locale is not specified.");return o}}exports.default=Translator;